using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using RimTransAI.Models;

namespace RimTransAI.Services;

public class FileGeneratorService
{
    /// <summary>
    /// 保存翻译结果到文件，并附带原文注释
    /// </summary>
    public int GenerateFiles(string modRootPath, string targetLang, IEnumerable<TranslationItem> items)
    {
        int filesCount = 0;
        
        // 1. 只处理状态为 "已翻译" 的条目
        var validItems = items.Where(x => !string.IsNullOrEmpty(x.TranslatedText) && x.Status == "已翻译").ToList();
        
        if (!validItems.Any()) return 0;

        // 2. 按“来源文件”分组
        var fileGroups = validItems.GroupBy(x => x.FilePath);

        foreach (var group in fileGroups)
        {
            var originalFilePath = group.Key;
            var groupItems = group.ToList();
            var version = groupItems.First().Version;

            // 3. 计算目标路径
            string targetPath = DetermineOutputPath(modRootPath, originalFilePath, version, targetLang);
            if (string.IsNullOrEmpty(targetPath)) continue;

            // 4. 构建 XML 内容
            // 使用 XDocument 能够更好地控制格式
            var doc = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
            var root = new XElement("LanguageData");
            doc.Add(root);
            
            // 头部添加生成器标识
            root.Add(new XComment(" Generated by RimTransAI "));

            foreach (var item in groupItems)
            {
                // --- 关键修改：添加原文注释 ---

                // XML 注释中不能包含 "--"，必须转义，否则游戏加载会报错
                // 同时处理其他可能导致 XML 注释格式错误的字符
                string safeOriginal = item.OriginalText
                    .Replace("--", "- -")      // 双横线转义
                    .Replace("<!--", "< !--")  // 注释开始标记转义
                    .Replace("-->", "-- >");   // 注释结束标记转义

                // 格式： EN: Original Text
                root.Add(new XComment($" EN: {safeOriginal} "));

                // --- 添加翻译内容 ---

                // 创建节点 <Key>Value</Key>
                // 如果是 DefInjected，Key 类似于 ThingDef.label
                root.Add(new XElement(item.Key, item.TranslatedText));
            }

            // 5. 写入磁盘
            try
            {
                var dir = Path.GetDirectoryName(targetPath);
                if (!Directory.Exists(dir)) Directory.CreateDirectory(dir!);

                // Save 方法会自动格式化 XML（缩进和换行）
                doc.Save(targetPath);
                filesCount++;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"写入失败 {targetPath}: {ex.Message}");
            }
        }

        return filesCount;
    }

    private string DetermineOutputPath(string modRoot, string originalPath, string version, string targetLang)
    {
        string contentRoot = string.IsNullOrEmpty(version) ? modRoot : Path.Combine(modRoot, version);

        // 标准化路径分隔符，统一使用当前系统的分隔符
        string normalizedPath = originalPath.Replace('\\', Path.DirectorySeparatorChar)
                                            .Replace('/', Path.DirectorySeparatorChar);

        // 处理 DefInjected
        string defsPattern = $"{Path.DirectorySeparatorChar}Defs{Path.DirectorySeparatorChar}";
        int defsIndex = normalizedPath.LastIndexOf(defsPattern, StringComparison.OrdinalIgnoreCase);

        if (defsIndex != -1)
        {
            // 跳过 "/Defs/" 部分
            string relativePath = normalizedPath.Substring(defsIndex + defsPattern.Length);
            return Path.Combine(contentRoot, "Languages", targetLang, "DefInjected", relativePath);
        }

        // 处理 Keyed
        if (normalizedPath.Contains("Keyed", StringComparison.OrdinalIgnoreCase))
        {
            string fileName = Path.GetFileName(normalizedPath);
            return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", fileName);
        }

        return string.Empty;
    }
}