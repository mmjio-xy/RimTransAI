using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using RimTransAI.Models;

namespace RimTransAI.Services;

public class FileGeneratorService
{
    /// <summary>
    /// 保存翻译结果到文件，并附带原文注释
    /// </summary>
    public int GenerateFiles(string modRootPath, string targetLang, IEnumerable<TranslationItem> items)
    {
        int filesCount = 0;
        
        // 1. 只处理状态为 "已翻译" 的条目
        var validItems = items.Where(x => !string.IsNullOrEmpty(x.TranslatedText) && x.Status == "已翻译").ToList();
        
        if (!validItems.Any()) return 0;

        // 2. 按“来源文件”分组
        var fileGroups = validItems.GroupBy(x => x.FilePath);

        foreach (var group in fileGroups)
        {
            var originalFilePath = group.Key;
            var groupItems = group.ToList();
            var version = groupItems.First().Version;

            // 3. 计算目标路径
            string targetPath = DetermineOutputPath(modRootPath, originalFilePath, version, targetLang);
            if (string.IsNullOrEmpty(targetPath)) continue;

            // 4. 构建 XML 内容
            // 使用 XDocument 能够更好地控制格式
            var doc = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
            var root = new XElement("LanguageData");
            doc.Add(root);
            
            // 头部添加生成器标识
            root.Add(new XComment(" Generated by RimTransAI "));

            foreach (var item in groupItems)
            {
                // --- 关键修改：添加原文注释 ---
                
                // XML 注释中不能包含 "--"，必须转义，否则游戏加载会报错
                string safeOriginal = item.OriginalText.Replace("--", "- -");
                
                // 格式： EN: Original Text
                root.Add(new XComment($" EN: {safeOriginal} "));

                // --- 添加翻译内容 ---
                
                // 创建节点 <Key>Value</Key>
                // 如果是 DefInjected，Key 类似于 ThingDef.label
                root.Add(new XElement(item.Key, item.TranslatedText));
            }

            // 5. 写入磁盘
            try
            {
                var dir = Path.GetDirectoryName(targetPath);
                if (!Directory.Exists(dir)) Directory.CreateDirectory(dir!);

                // Save 方法会自动格式化 XML（缩进和换行）
                doc.Save(targetPath);
                filesCount++;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"写入失败 {targetPath}: {ex.Message}");
            }
        }

        return filesCount;
    }

    private string DetermineOutputPath(string modRoot, string originalPath, string version, string targetLang)
    {
        string contentRoot = string.IsNullOrEmpty(version) ? modRoot : Path.Combine(modRoot, version);

        // 处理 DefInjected
        if (originalPath.Contains($"{Path.DirectorySeparatorChar}Defs{Path.DirectorySeparatorChar}") || originalPath.Contains("\\Defs\\"))
        {
            int index = originalPath.LastIndexOf($"{Path.DirectorySeparatorChar}Defs{Path.DirectorySeparatorChar}", StringComparison.Ordinal);
            if (index == -1) index = originalPath.LastIndexOf("\\Defs\\", StringComparison.Ordinal);
            
            if (index != -1)
            {
                // +6 是为了跳过 "/Defs/" 或 "\Defs\"
                string relativePath = originalPath.Substring(index + 6); 
                return Path.Combine(contentRoot, "Languages", targetLang, "DefInjected", relativePath);
            }
        }

        // 处理 Keyed
        if (originalPath.Contains("Keyed"))
        {
             string fileName = Path.GetFileName(originalPath);
             return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", fileName);
        }

        return string.Empty;
    }
}