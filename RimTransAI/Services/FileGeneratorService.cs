using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using RimTransAI.Models;

namespace RimTransAI.Services;

public class FileGeneratorService
{
    /// <summary>
    /// 保存翻译结果到文件，并附带原文注释
    /// </summary>
    public int GenerateFiles(string modRootPath, string targetLang, IEnumerable<TranslationItem> items)
    {
        int filesCount = 0;
        
        // 1. 只处理状态为 "已翻译" 的条目
        var validItems = items.Where(x => !string.IsNullOrEmpty(x.TranslatedText) && x.Status == "已翻译").ToList();
        
        if (!validItems.Any()) return 0;

        // 2. 按 DefType 和 Version 分组（DefInjected 使用 DefType 作为子文件夹）
        // 对于 Keyed 类型，使用原始文件路径分组
        var fileGroups = validItems.GroupBy(x => new { x.DefType, x.Version, x.FilePath });

        foreach (var group in fileGroups)
        {
            var originalFilePath = group.Key.FilePath;
            var defType = group.Key.DefType;
            var version = group.Key.Version;
            var groupItems = group.ToList();

            // 3. 计算目标路径
            string targetPath = DetermineOutputPath(modRootPath, originalFilePath, defType, version, targetLang);
            if (string.IsNullOrEmpty(targetPath)) continue;

            // 4. 构建 XML 内容
            // 使用 XDocument 能够更好地控制格式
            var doc = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
            var root = new XElement("LanguageData");
            doc.Add(root);
            
            // 头部添加生成器标识
            root.Add(new XComment(" Generated by RimTransAI "));

            foreach (var item in groupItems)
            {
                // --- 关键修改：添加原文注释 ---

                // XML 注释中不能包含 "--"，必须转义，否则游戏加载会报错
                // 同时处理其他可能导致 XML 注释格式错误的字符
                string safeOriginal = item.OriginalText
                    .Replace("--", "- -")      // 双横线转义
                    .Replace("<!--", "< !--")  // 注释开始标记转义
                    .Replace("-->", "-- >");   // 注释结束标记转义

                // 格式： EN: Original Text
                root.Add(new XComment($" EN: {safeOriginal} "));

                // --- 添加翻译内容 ---

                // 创建节点 <Key>Value</Key>
                // 如果是 DefInjected，Key 类似于 ThingDef.label
                root.Add(new XElement(item.Key, item.TranslatedText));
            }

            // 5. 写入磁盘
            try
            {
                var dir = Path.GetDirectoryName(targetPath);
                if (!Directory.Exists(dir)) Directory.CreateDirectory(dir!);

                // 检查并移除只读属性（Steam Workshop 常见问题）
                if (File.Exists(targetPath))
                {
                    var fileInfo = new FileInfo(targetPath);
                    if (fileInfo.IsReadOnly)
                    {
                        Logger.Warning($"文件为只读，正在移除只读属性: {Path.GetFileName(targetPath)}");
                        fileInfo.IsReadOnly = false;
                    }
                }

                // Save 方法会自动格式化 XML（缩进和换行）
                doc.Save(targetPath);
                filesCount++;
                Logger.Debug($"已保存: {targetPath}");
            }
            catch (Exception ex)
            {
                Logger.Error($"写入失败 {targetPath}", ex);
            }
        }

        return filesCount;
    }

    private string DetermineOutputPath(string modRoot, string originalPath, string defType, string version, string targetLang)
    {
        string contentRoot = string.IsNullOrEmpty(version) ? modRoot : Path.Combine(modRoot, version);

        // 标准化路径分隔符，统一使用当前系统的分隔符
        string normalizedPath = originalPath.Replace('\\', Path.DirectorySeparatorChar)
                                            .Replace('/', Path.DirectorySeparatorChar);

        // 处理 DefInjected：强制使用 DefType 作为子文件夹名
        string defsPattern = $"{Path.DirectorySeparatorChar}Defs{Path.DirectorySeparatorChar}";
        int defsIndex = normalizedPath.LastIndexOf(defsPattern, StringComparison.OrdinalIgnoreCase);

        if (defsIndex != -1 && !string.IsNullOrEmpty(defType))
        {
            // 使用 DefType 作为子文件夹，文件名使用原始文件名
            string originalFileName = Path.GetFileName(normalizedPath);
            return Path.Combine(contentRoot, "Languages", targetLang, "DefInjected", defType, originalFileName);
        }

        // 处理 Keyed
        string keyedPattern = $"{Path.DirectorySeparatorChar}Keyed{Path.DirectorySeparatorChar}";
        int keyedIndex = normalizedPath.LastIndexOf(keyedPattern, StringComparison.OrdinalIgnoreCase);

        if (keyedIndex != -1)
        {
            // 保留 Keyed 之后的完整子目录结构
            // 例如: Keyed/Battle/Strings.xml -> Languages/ChineseSimplified/Keyed/Battle/Strings.xml
            string relativePath = normalizedPath.Substring(keyedIndex + keyedPattern.Length);
            return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", relativePath);
        }

        // 处理 DLL 或虚拟路径（来自反射分析的数据）
        if (normalizedPath.Contains(".dll", StringComparison.OrdinalIgnoreCase) ||
            normalizedPath.StartsWith("[") ||
            !Path.IsPathRooted(normalizedPath))
        {
            // 强制保存到 Keyed/Generated_Code.xml
            Logger.Info($"检测到虚拟路径或 DLL 来源: {originalPath}，保存到 Generated_Code.xml");
            return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", "Generated_Code.xml");
        }

        // 未识别的路径类型，记录警告
        Logger.Warning($"无法确定输出路径: {originalPath}");
        return string.Empty;
    }
}