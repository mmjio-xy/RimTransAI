using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using RimTransAI.Models;

namespace RimTransAI.Services;

public class FileGeneratorService
{
    /// <summary>
    /// 保存翻译结果到文件，并附带原文注释
    /// </summary>
    public int GenerateFiles(string modRootPath, string targetLang, IEnumerable<TranslationItem> items)
    {
        var filesCount = 0;
        
        // 1. 过滤有效条目
        var validItems = items.Where(x => !string.IsNullOrEmpty(x.TranslatedText) && x.Status == "已翻译").ToList();
        
        if (validItems.Count == 0) return 0;

        // 2. 按 DefType 和 Version 分组
        var fileGroups = validItems.GroupBy(x => new { x.DefType, x.Version, x.FilePath });

        foreach (var group in fileGroups)
        {
            var originalFilePath = group.Key.FilePath;
            var defType = group.Key.DefType;
            var version = group.Key.Version;
            var groupItems = group.ToList();

            // 3. 计算目标路径 (修复了同名文件覆盖问题)
            string targetPath = DetermineOutputPath(modRootPath, originalFilePath, defType, version, targetLang);
            if (string.IsNullOrEmpty(targetPath)) continue;

            // 4. 构建 XML 内容
            var doc = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
            var root = new XElement("LanguageData");
            doc.Add(root);
            
            root.Add(new XComment(" Generated by RimTransAI "));

            foreach (var item in groupItems)
            {
                try 
                {
                    // 确保 OriginalText 不为空，且 Replace 参数正确
                    string textToSafe = item.OriginalText ?? "";

                    // 【修复】移除错误的 Replace(oldValue: "", ...) 调用
                    // Replace 方法的第一个参数不能为空字符串
                    string safeOriginal = textToSafe
                        .Replace("--", "- -");      // 防止 XML 注入

                    root.Add(new XComment($" EN: {safeOriginal} "));

                    // 创建翻译节点
                    root.Add(new XElement(item.Key, item.TranslatedText));
                }
                catch (Exception ex)
                {
                    // 捕获单个条目的错误，防止整个文件保存失败
                    Logger.Error($"XML 节点创建失败 (Key: {item.Key}) - {ex.Message}");
                    root.Add(new XComment($" ERROR: Could not save key '{item.Key}' "));
                }
            }

            // 5. 写入磁盘
            try
            {
                var dir = Path.GetDirectoryName(targetPath);
                if (!Directory.Exists(dir)) Directory.CreateDirectory(dir!);

                if (File.Exists(targetPath))
                {
                    var fileInfo = new FileInfo(targetPath);
                    if (fileInfo.IsReadOnly) fileInfo.IsReadOnly = false;
                }

                doc.Save(targetPath);
                filesCount++;
                Logger.Debug($"已保存: {targetPath}");
            }
            catch (Exception ex)
            {
                Logger.Error($"写入文件失败 {targetPath}", ex);
            }
        }

        return filesCount;
    }

    private string DetermineOutputPath(string modRoot, string originalPath, string defType, string version, string targetLang)
    {
        string contentRoot = string.IsNullOrEmpty(version) ? modRoot : Path.Combine(modRoot, version);
        
        // 标准化路径
        string normalizedPath = originalPath.Replace('\\', Path.DirectorySeparatorChar)
                                            .Replace('/', Path.DirectorySeparatorChar);

        // 处理 Keyed
        string keyedPattern = $"{Path.DirectorySeparatorChar}Keyed{Path.DirectorySeparatorChar}";
        int keyedIndex = normalizedPath.LastIndexOf(keyedPattern, StringComparison.OrdinalIgnoreCase);

        if (keyedIndex != -1)
        {
            string relativePath = normalizedPath.Substring(keyedIndex + keyedPattern.Length);
            return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", relativePath);
        }

        // 处理 DefInjected
        if (!string.IsNullOrEmpty(defType))
        {
            string defsPattern = $"{Path.DirectorySeparatorChar}Defs{Path.DirectorySeparatorChar}";
            int defsIndex = normalizedPath.LastIndexOf(defsPattern, StringComparison.OrdinalIgnoreCase);

            string relativeFileName;
            if (defsIndex != -1)
            {
                // 保留 Defs 后的子目录结构，防止同名文件冲突
                relativeFileName = normalizedPath.Substring(defsIndex + defsPattern.Length);
            }
            else
            {
                relativeFileName = Path.GetFileName(normalizedPath);
            }

            return Path.Combine(contentRoot, "Languages", targetLang, "DefInjected", defType, relativeFileName);
        }

        // 处理虚拟路径/DLL
        if (normalizedPath.Contains(".dll", StringComparison.OrdinalIgnoreCase) || 
            normalizedPath.StartsWith("[") || 
            !Path.IsPathRooted(normalizedPath))
        {
            return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", "Generated_Code.xml");
        }

        // 兜底
        return Path.Combine(contentRoot, "Languages", targetLang, "Keyed", "Misc_Generated.xml");
    }
}